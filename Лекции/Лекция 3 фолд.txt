Инфиксные операции:
Приоритет 5, правоассоциативная, infixl - левоассоциативная
infixr 5 +++

[] +++ y = y
(x:xs) +++ y = x: (xs +++ y)

Операция !! берет из списка ный элемент.
Сверстка списка:
fold - свертка foldl
			   foldr

(((a `f` x1) `f` x2) `f` x2)
foldl (+) 0 = summa spisok
foldl (*) 1 = prod
foldl (++) [] = id

foldr' f a ([]) = a 
foldr' f a (x:xs) = (x `f` (foldr' f a xs)) 

foldl (\acc _ -> acc + 1) 0 [1..10] - длина
1)Список всех простых чисел
2)Список всех чисел Фиббоначи
С помощью foldl написать функции maxl, minl, length

take n l - не более чем н первых элементов списка

data Tsil a = Lin | Snoc (Tsil a) a
	deriving(Show)
	
foldr' f a (Lin) = a 
foldr' f a (Snoc xs x) = (x `f` (foldr' f a xs)) 

addEl :: Tsil a -> a -> Tsil a
addEl list b = Snoc list b

addFs Lin b = Snoc Lin b
addFs (Snoc xs x) b = addEl (addFs xs b) x

toList :: Tsil a -> [a]
toList (Snoc xs x) = (toList xs)++[x]
toList Lin = [] 

fromList :: [a] -> Tsil a
fromList list = case list of
	[] -> Lin
	otherwise -> addFs (fromList (tail list)) (head list)

length' :: Tsil a -> Int
length' list = case list of 
	Lin -> 0
	Snoc xs _ -> length' xs +1 

map' :: (a -> b) -> Tsil a -> Tsil b
map' func list = case list of
	Lin -> Lin
	Snoc xs x -> Snoc (map' func xs) (func x)

reverse' (Snoc xs x) = addFs (reverse' xs) x
reverse' Lin = Lin 

concat' Lin list = list
concat' (Snoc xs x) list = Snoc (xs `concat'` list) x
	
flatten' list = foldr' concat' Lin list

	


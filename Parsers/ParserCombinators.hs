module ParserCombinators where

newtype Parser s a = P(s -> [(a,s)])

val :: a -> Parser s a
val v = P(\s -> [(v,s)]) --Парсерный комбинатор, который выполняется без поглощения входной строки и возвращает единственный результат v

fail :: Parser s a
fail = P (\inp -> [])--Парсер принимающий вход и возвращающий ничего

item :: Parser [s] s --Парсер принимающий строку(список символов) и возвращающий пару - первый символ, и остаток
item = P p where
	p (x:xs) = [(x,xs)]
	p _ = []
	
sym :: Eq s => s -> Parser [s] s
sym c = P p where --Парсер принимающий строку и символ и парсящий этот символ в строке
	p (x:xs) | x==c = [(x,xs)]
	p _ = []
	
anyq :: Parser [s] ()
anyq = P p where
	p (_:xs) = [((), xs)] -- Парсер возвращающий остаток строки кроме первого символа и что-то и  ничего
	p [] = [((), [])]
	
apply :: Parser s a -> s -> [(a,s)] -- Применятель парсера к строке
apply (P p) = p

lift :: Parser s a -> (b ->Parser s a)
lift p = (\inp -> p)  --Создает парсер-комбинатор, который по некоторой b выдает нужный нам парсер

infixl 2 |||
(|||) :: Parser s a -> Parser s a -> Parser s a --Создает парсер-комбинатор, который принимает два парсера и создает парсер, который объединяет результаты этих двух парсеров
(P p) ||| (P q) = P(\s -> p s ++ q s)

infixl 3 ||>
(||>) :: Parser s a -> (a -> Parser s b) -> Parser s b -- Парсер р применяется ко входу, выдавая список (value,string) пар. Если f - это функция, которая берет значение и возвращает парсер, она может быть приложена к каждому остатку в свою очередь. В результате получается список списков (value,string) пар, который затем может быть преобразован, используя операцию конкатенации.
P p ||> f = P(\s -> concat[apply(f a) s| (a, s)<-p s])--Композиция парсеров

many :: Parser s a -> Parser s [a]
many p  = val [] ||| p ||> (\inp -> many p ||> val . (inp:))--Принимает парсер, парсящий на [a,s], возвращает [([],s+a);(a,s);(aa,s-a);(aaa,s-aa)..]

some :: Parser s a -> Parser s [a]
some p  = p ||> (\inp -> many p ||> val . (inp:))--Тоже только без пустого

opt :: Parser s a -> Parser s (Maybe a) -- [(Just a, s)]++[(Nothing,s)]
opt p = p ||> val . Just ||| val Nothing

eof :: Eq s => [(a, [s])] -> [a]
eof = map fst . filter ((==[]) . snd) -- Список элементов из а, у которых строка(нераспарсенный остаток) закончился(распарсилось до конца строки), т.е. берем список  из результатов распарсивания и к каждому из элементов проверяем, пуста ли нераспарсеный остаток